// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// AcsRegistryData is an auto generated low-level Go binding around an user-defined struct.
type AcsRegistryData struct {
	Name       string
	Size       *big.Int
	Owner      string
	Cid        string
	Encryption string
	Creation   string
	Revision   string
	Metadata   string
}

// AcsRegistryPermission is an auto generated low-level Go binding around an user-defined struct.
type AcsRegistryPermission struct {
	Id   string
	List string
}

// AcsRegistryRole is an auto generated low-level Go binding around an user-defined struct.
type AcsRegistryRole struct {
	Id   string
	Name string
}

// AcsRegistryUser is an auto generated low-level Go binding around an user-defined struct.
type AcsRegistryUser struct {
	Id      string
	Name    string
	Did     string
	Role    []string
	Addr    string
	Contact string
}

// ContractsMetaData contains all meta data concerning the Contracts contract.
var ContractsMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"}],\"name\":\"DataDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"}],\"name\":\"DataPut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newOwner\",\"type\":\"string\"}],\"name\":\"DataTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"}],\"name\":\"DataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"PermissionGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"PermissionRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RoleDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"roleID\",\"type\":\"string\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RoleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"roleID\",\"type\":\"string\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"UserDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"UserUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataOwner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"}],\"name\":\"deleteData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"}],\"name\":\"deleteRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"}],\"name\":\"deleteUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"}],\"name\":\"getData\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"owner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"encryption\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creation\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"revision\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"internalType\":\"structAcsRegistry.Data\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"}],\"name\":\"getDataOwner\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_permissionID\",\"type\":\"string\"}],\"name\":\"getPermission\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"list\",\"type\":\"string\"}],\"internalType\":\"structAcsRegistry.Permission\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"}],\"name\":\"getRole\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"structAcsRegistry.Role\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"did\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"role\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"addr\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contact\",\"type\":\"string\"}],\"internalType\":\"structAcsRegistry.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_permissionID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_permissionList\",\"type\":\"string\"}],\"name\":\"grantPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_dataSize\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_dataOwner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataEncryption\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataCreation\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataRevision\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataMeta\",\"type\":\"string\"}],\"name\":\"putData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_roleName\",\"type\":\"string\"}],\"name\":\"registerRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userDID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userRole\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userAddr\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userContact\",\"type\":\"string\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_permissionID\",\"type\":\"string\"}],\"name\":\"revokePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataOwner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newOwner\",\"type\":\"string\"}],\"name\":\"transferData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataOwner\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataCID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_dataMeta\",\"type\":\"string\"}],\"name\":\"updateData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_roleID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_roleName\",\"type\":\"string\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_userID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userDID\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userRole\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userAddr\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_userContact\",\"type\":\"string\"}],\"name\":\"updateUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60808060405234601557612bf1908161001b8239f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c806302f9888e1461214057806303fe93fe146120065780630b1a562514611f3557806315f5744a14611dad5780632808235f14611cd55780632c8b076614611c5757806331feb671146119d057806355995dba1461190a5780635884c96b146116de5780636e9067fb146116725780637832a0d114610fdd578063a69ea63c14610ee7578063ae55c88814610c68578063d369516114610b6c578063d676260f14610a8e578063dba4d945146109f0578063ddc46c6214610976578063eb3a8b4b1461019d5763f29f968d146100ed57600080fd5b34610198576020366003190112610198576004356001600160401b03811161019857610120610127913690600401612216565b36916124b6565b6020815191012080600052600260205261014f6101486040600020546124fc565b15156129bc565b8060005260026020526101716001604060002061016b8161254d565b0161254d565b7fef9f0985bfd169b17c43b61ad1e35c0c7fe75dd675fb0fe8d914a12fd12631c6600080a2005b600080fd5b3461019857610100366003190112610198576004356001600160401b038111610198576101ce903690600401612216565b906044356001600160401b038111610198576101ee903690600401612216565b92906064356001600160401b0381116101985761020f903690600401612216565b90916084356001600160401b03811161019857610230903690600401612216565b909260a4356001600160401b03811161019857610251903690600401612216565b93909460c4356001600160401b03811161019857610273903690600401612216565b96909160e4356001600160401b03811161019857610295903690600401612216565b9990946102a33688846124b6565b602081519101209c8d60005260016020526102c56003604060002001546124fc565b61093b576040519c6102d68e612479565b36906102e1926124b6565b8c5260208c019d8e602435905236906102f9926124b6565b9560408c01968752369061030c926124b6565b9560608b01968752369061031f926124b6565b9560808a019687523690610332926124b6565b9560a089019687523690610345926124b6565b9560c088019687523690610358926124b6565b9760e08701988952876000526001602052604060002096518051906001600160401b038211610680576103958261038f8b546124fc565b8b61268c565b602090601f83116001146108d4576103c69291600091836108c9575b50508160011b916000199060031b1c19161790565b87555b51600187015551805160028701916001600160401b038211610680576103f9826103f385546124fc565b8561268c565b602090601f8311600114610862576104299291600091836108575750508160011b916000199060031b1c19161790565b90555b51805160038601916001600160401b03821161068057610450826103f385546124fc565b602090601f83116001146107f0576104809291600091836107e55750508160011b916000199060031b1c19161790565b90555b51805160048501916001600160401b038211610680576104a7826103f385546124fc565b602090601f831160011461077e576104d79291600091836107735750508160011b916000199060031b1c19161790565b90555b51805160058401916001600160401b038211610680576104fe826103f385546124fc565b602090601f831160011461070c5761052e9291600091836106965750508160011b916000199060031b1c19161790565b90555b51805160068301916001600160401b03821161068057610555826103f385546124fc565b602090601f83116001146106a157918061058a9260079695946000926106965750508160011b916000199060031b1c19161790565b90555b0191519182516001600160401b038111610680576105b5816105af84546124fc565b8461268c565b6020601f821160011461061b5781906105e69394956000926106105750508160011b916000199060031b1c19161790565b90555b7f9e8a898414956758234305855c8bb7a18a44a908dab1c20f1da8bb55ffa4fce8600080a2005b0151905085806103b1565b601f1982169083600052806000209160005b8181106106685750958360019596971061064f575b505050811b0190556105e9565b015160001960f88460031b161c19169055848080610642565b9192602060018192868b01518155019401920161062d565b634e487b7160e01b600052604160045260246000fd5b0151905088806103b1565b90601f1983169184600052816000209260005b8181106106f45750916001939185600798979694106106db575b505050811b01905561058d565b015160001960f88460031b161c191690558780806106ce565b929360206001819287860151815501950193016106b4565b90601f1983169184600052816000209260005b81811061075b5750908460019594939210610742575b505050811b019055610531565b015160001960f88460031b161c19169055878080610735565b9293602060018192878601518155019501930161071f565b0151905089806103b1565b90601f1983169184600052816000209260005b8181106107cd57509084600195949392106107b4575b505050811b0190556104da565b015160001960f88460031b161c191690558880806107a7565b92936020600181928786015181550195019301610791565b015190508a806103b1565b90601f1983169184600052816000209260005b81811061083f5750908460019594939210610826575b505050811b019055610483565b015160001960f88460031b161c19169055898080610819565b92936020600181928786015181550195019301610803565b015190508b806103b1565b90601f1983169184600052816000209260005b8181106108b15750908460019594939210610898575b505050811b01905561042c565b015160001960f88460031b161c191690558a808061088b565b92936020600181928786015181550195019301610875565b015190508c806103b1565b90601f198316918a600052816000209260005b818110610923575090846001959493921061090a575b505050811b0187556103c9565b015160001960f88460031b161c191690558b80806108fd565b929360206001819287860151815501950193016108e7565b60405162461bcd60e51b81526020600482015260136024820152724461746120616c72656164792065786973747360681b6044820152606490fd5b34610198576020366003190112610198576004356001600160401b038111610198576109a96109b9913690600401612216565b6109b1612b51565b5036916124b6565b6020815191012060005260036020526109ec6109d86040600020612b6a565b604051918291602083526020830190612416565b0390f35b34610198576020366003190112610198576004356001600160401b03811161019857610120610a23913690600401612216565b60208151910120806000526001602052610a4e610a476003604060002001546124fc565b15156129fa565b60005260016020526109ec610a73610a7a600260406000200160405192838092612609565b0382612495565b604051918291602083526020830190612367565b3461019857610ad57f7e3b036b87e87f04c2fa478ec61db001b3577118d4e59ee42b7f073e42b887f7610b31610afa610ac6366123a8565b969492909593989136916124b6565b6020815191012096876000526001602052610120610a476003604060002001546124fc565b60208151910120856000526001602052610a73610b24600260406000200160405192838092612609565b6020815191012014612a38565b610b3c3683836124b6565b50836000526001602052610b58828260026040600020016126d1565b610b67604051928392836127c0565b0390a2005b34610198576020366003190112610198576004356001600160401b03811161019857610120610b9f913690600401612216565b60208151910120806000526000602052610bc7610bc06040600020546124fc565b151561259d565b8060005260006020526040600020610bde8161254d565b610bea6001820161254d565b610bf66002820161254d565b600381018054906000815581610c41575b83610c1a60058561016b6004820161254d565b7fc26eb30613e535870aeacfc24e58a8fb60e992f0d8bfe04ec9c98db26b53c5e5600080a2005b6000526020600020908101905b81811015610c075780610c6260019261254d565b01610c4e565b34610198576020366003190112610198576004356001600160401b03811161019857610c98903690600401612216565b604051610ca481612479565b60608152602081016000905260408101606090526060810160609052608081016060905260a081016060905260c081016060905260e001606090523690610cea926124b6565b80519060200120806000526001602052604060002060030154610d0c906124fc565b1515610d17906129fa565b60005260016020526040600020604051610d3081612479565b60405180610d3e8185612609565b03610d499082612495565b8152600182015460208201908152604051929083610d6a8160028501612609565b03610d759085612495565b60408381019485525180610d8c8160038601612609565b03610d979082612495565b6060840190815260405180610daf8160048701612609565b03610dba9082612495565b608085019081526040519182610dd38160058801612609565b03610dde9084612495565b60a086019283526040519384610df78160068901612609565b03610e029086612495565b60c0870194855260405180600781980190610e1c91612609565b03610e279087612495565b60e0870195865260405197889760208952516020890161010090526101208901610e5091612367565b9151604089015251878203601f19016060890152610e6e9190612367565b9051868203601f19016080880152610e869190612367565b9051858203601f190160a0870152610e9e9190612367565b9051848203601f190160c0860152610eb69190612367565b9051838203601f190160e0850152610ece9190612367565b9051828203601f19016101008401526109ec9190612367565b3461019857610f08610f57610f2d610efe36612243565b95919536916124b6565b6020815191012093846000526001602052610120610a476003604060002001546124fc565b60208151910120826000526001602052610a73610b24600260406000200160405192838092612609565b806000526001602052610fb660076040600020610f738161254d565b60006001820155610f866002820161254d565b610f926003820161254d565b610f9e6004820161254d565b610faa6005820161254d565b61016b6006820161254d565b7f5236602858fa598e0b1c0f4eab28a46d135d76a3a28731d8dca95bc52c91bc33600080a2005b3461019857610feb36612293565b976110008b9a9295989397969c9b1515612970565b61100b368b8d6124b6565b602081519101209a8b600052600060205261102a6040600020546124fc565b6116375760409c8d998a519a611040818d612495565b60018c52601f19018b60005b828110611625575050503690611061926124b6565b61106a8a612bae565b5261107489612bae565b508c519a6110818c61245e565b369061108c926124b6565b8a523690611099926124b6565b936020890194855236906110ac926124b6565b938988019485526060880195865236906110c5926124b6565b946080870195865236906110d8926124b6565b9660a0860197885286600052600060205260002094518051906001600160401b038211610680576111138261110d89546124fc565b8961268c565b602090601f83116001146115be576111439291600091836107e55750508160011b916000199060031b1c19161790565b85555b51805160018601916001600160401b0382116106805761116a826103f385546124fc565b602090601f83116001146115575761119a9291600091836107e55750508160011b916000199060031b1c19161790565b90555b51805160028501916001600160401b038211610680576111c1826103f385546124fc565b602090601f83116001146114f0576111f19291600091836107735750508160011b916000199060031b1c19161790565b90555b5180516003840191600160401b82116106805782548284558083106114c1575b50602001916000526020600020916000905b8282106113db57505050506004820190518051906001600160401b03821161068057611256826103f385546124fc565b602090601f831160011461137057918061128b9260059695946000926106965750508160011b916000199060031b1c19161790565b90555b0191519182516001600160401b038111610680576112b0816105af84546124fc565b6020601f821160011461130b5781906112e19394956000926106105750508160011b916000199060031b1c19161790565b90555b7f78997021e09413de1e36500ed07f9f6c73541162817fc3ea6a115e5e3d3affb9600080a2005b601f1982169083600052806000209160005b8181106113585750958360019596971061133f575b505050811b0190556112e4565b015160001960f88460031b161c19169055848080611332565b9192602060018192868b01518155019401920161131d565b90601f1983169184600052816000209260005b8181106113c35750916001939185600598979694106113aa575b505050811b01905561128e565b015160001960f88460031b161c1916905587808061139d565b92936020600181928786015181550195019301611383565b80518051906001600160401b03821161068057611402826113fc88546124fc565b8861268c565b602090601f8311600114611454579261143a836001959460209487966000926114495750508160011b916000199060031b1c19161790565b87555b01940191019092611226565b015190508e806103b1565b90601f1983169187600052816000209260005b8181106114a95750936020936001969387969383889510611490575b505050811b01875561143d565b015160001960f88460031b161c191690558d8080611483565b92936020600181928786015181550195019301611467565b8360005282602060002091820191015b8181106114de5750611214565b806114ea60019261254d565b016114d1565b90601f1983169184600052816000209260005b81811061153f5750908460019594939210611526575b505050811b0190556111f4565b015160001960f88460031b161c19169055888080611519565b92936020600181928786015181550195019301611503565b90601f1983169184600052816000209260005b8181106115a6575090846001959493921061158d575b505050811b01905561119d565b015160001960f88460031b161c19169055898080611580565b9293602060018192878601518155019501930161156a565b90601f1983169188600052816000209260005b81811061160d57509084600195949392106115f4575b505050811b018555611146565b015160001960f88460031b161c191690558980806115e7565b929360206001819287860151815501950193016115d1565b60606020828194010152018c9061104c565b60405162461bcd60e51b81526020600482015260136024820152725573657220616c72656164792065786973747360681b6044820152606490fd5b34610198576020366003190112610198576004356001600160401b038111610198576109a96116a5913690600401612216565b602081519101208060005260026020526116c66101486040600020546124fc565b60005260026020526109ec6109d86040600020612b6a565b34610198576116fb6116ef36612243565b939192909236916124b6565b602081519101209182600052600060205261171d610bc06040600020546124fc565b8260005260006020526003604060002001908154156000146117715760405162461bcd60e51b815260206004820152601060248201526f139bc81c9bdb1948185cdcda59db995960821b6044820152606490fd5b60005b8254808210156118df57610a7361179b61178e84876125db565b5060405192838092612609565b602081519101206117ad3685886124b6565b60208151910120146117c25750600101611774565b9293919260001981019081116118c9576117df6117e791866125db565b5091856125db565b91909161189d576117f791612a7a565b825480156118b3576000190161180d81856125db565b94909461189d57846118407f94a5751b72e16c553db8e06715db8751e285f76cb50d9275da249f2f30b3b3bf96546124fc565b9081611859575b505055610b67604051928392836127c0565b81601f600093116001146118715750555b8680611847565b8183526020832061188d91601f0160051c810190600101612536565b808252816020812091555561186a565b634e487b7160e01b600052600060045260246000fd5b634e487b7160e01b600052603160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b505090507f94a5751b72e16c553db8e06715db8751e285f76cb50d9275da249f2f30b3b3bf91610b58565b346101985761193061195561197f611921366123a8565b959492909693979136916124b6565b6020815191012095866000526001602052610120610a476003604060002001546124fc565b60208151910120846000526001602052610a73610b24600260406000200160405192838092612609565b826000526001602052604060002091816119bc575b837f3127c1223c3e044893fdbef142783b113140774723e7a54693844985a4f8fc06600080a2005b60076119c893016126d1565b818080611994565b34610198576020366003190112610198576004356001600160401b03811161019857611a03611a36913690600401612216565b606060a0604051611a138161245e565b8281528260208201528260408201528280820152826080820152015236916124b6565b60208151910120806000526000602052611a57610bc06040600020546124fc565b60005260006020526040600020604051611a708161245e565b604051611a8181610a738186612609565b8152604051611a9781610a738160018701612609565b6020820190815260405192611aba84611ab38160028501612609565b0385612495565b60408301938452600381019182546001600160401b0381116106805760208160051b0193611aeb6040519586612495565b818552602085019060005260206000206000915b838310611c3257611b768860058989611b9c8e611b898c60608801958652611b5360405195611b3c87611b358160048501612609565b0388612495565b60808a01968752611b35604051809a819301612609565b60a0880196875260405198899860208a525160c060208b015260e08a0190612367565b9051888203601f190160408a0152612367565b9051868203601f19016060880152612367565b915191601f19858203016080860152825180825260208201916020808360051b8301019501926000915b838310611bfd5788806109ec8a611bea8b8b51601f198683030160a0870152612367565b9051838203601f190160c0850152612367565b9193969750919394602080611c1e600193601f198682030187528a51612367565b980193019301909288979695949293611bc6565b600160208192604051611c4981610a738189612609565b815201920192019190611aff565b3461019857611c76611cae611c6b36612243565b9290949136916124b6565b6020815191012092836000526002602052611c986101486040600020546124fc565b83600052600260205260016040600020016126d1565b7f5e293651729dbde44d92d54c33bc997eac7c3742e57f302f71336f176a39e4ab600080a2005b3461019857611ce336612243565b919092611cf13683836124b6565b6020815191012093846000526003602052611d106040600020546124fc565b611d7457611d4d93611d2c611d35936040519561012087612443565b845236916124b6565b602082015282600052600360205260406000206127e8565b7fa3d61b9cdf744675cae28d310353843537e9170210b3511e84bfe222b01b40ee600080a2005b60405162461bcd60e51b81526020600482015260116024820152705065726d697373696f6e2065786973747360781b6044820152606490fd5b3461019857611dd6611dbe36612293565b99610120819d939895969794999c929a9d1515612970565b60208151910120998a6000526000602052611df8610bc06040600020546124fc565b8a600052600060205260406000209980611f21575b505080611f0d575b505087600052600060205260036040600020019182548015600014611e9c5750611e3e92612790565b80611e88575b505081611e74575b837fdf3a752736081f0b857124cd76b543d42ea93c426e4ae00b28927d4de82ee102600080a2005b6005611e8093016126d1565b818080611e4c565b611e9591600486016126d1565b8480611e44565b60009060005b818110611ecb575b505015611eba575b505050611e3e565b611ec392612790565b868080611eb2565b610a73611edb61178e83896125db565b60208151910120611eed3687876124b6565b6020815191012003611f0157600101611ea2565b50505060018a80611eaa565b611f1a9160028a016126d1565b8880611e15565b611f2e9160018c016126d1565b8a80611e0d565b3461019857611f4336612243565b919092611f513683836124b6565b6020815191012093846000526002602052611f706040600020546124fc565b611fcb57611fa493611d2c611f8c936040519561012087612443565b602082015282600052600260205260406000206127e8565b7f4351843977dda133afcc2219e41c320efe8742e2a678b5db94b863e08d199394600080a2005b60405162461bcd60e51b8152602060048201526013602482015272526f6c6520616c72656164792065786973747360681b6044820152606490fd5b346101985761202261201736612243565b9290939136916124b6565b6020815191012091826000526000602052612044610bc06040600020546124fc565b82600052600060205260036040600020018054801560001461208f575090610b5883827f960490bb96f8fde4056c4450ff105ec595dd2eabea364f74759e0f5ea65f88e19594612790565b60005b8181106120ce575050906120c983827f960490bb96f8fde4056c4450ff105ec595dd2eabea364f74759e0f5ea65f88e19594612790565b610b58565b610a736120de61178e83866125db565b602081519101206120f03687876124b6565b602081519101201461210457600101612092565b60405162461bcd60e51b8152602060048201526014602482015273149bdb1948185b1c9958591e4819dc985b9d195960621b6044820152606490fd5b34610198576020366003190112610198576004356001600160401b03811161019857610120612173913690600401612216565b602081519101208060005260036020526121916040600020546124fc565b156121d9578060005260036020526121b26001604060002061016b8161254d565b7f4e675315fe96944f365f4da1440d600a41b31e9484ae6cc0fd9fc7cd4773af67600080a2005b60405162461bcd60e51b81526020600482015260156024820152745065726d697373696f6e206e6f742065786973747360581b6044820152606490fd5b9181601f84011215610198578235916001600160401b038311610198576020838186019501011161019857565b6040600319820112610198576004356001600160401b038111610198578161226d91600401612216565b92909291602435906001600160401b0382116101985761228f91600401612216565b9091565b60c0600319820112610198576004356001600160401b03811161019857816122bd91600401612216565b929092916024356001600160401b03811161019857816122df91600401612216565b929092916044356001600160401b038111610198578161230191600401612216565b929092916064356001600160401b038111610198578161232391600401612216565b929092916084356001600160401b038111610198578161234591600401612216565b9290929160a435906001600160401b0382116101985761228f91600401612216565b919082519283825260005b848110612393575050826000602080949584010152601f8019910116010190565b80602080928401015182828601015201612372565b6060600319820112610198576004356001600160401b03811161019857816123d291600401612216565b929092916024356001600160401b03811161019857816123f491600401612216565b92909291604435906001600160401b0382116101985761228f91600401612216565b61244091602061242f8351604084526040840190612367565b920151906020818403910152612367565b90565b604081019081106001600160401b0382111761068057604052565b60c081019081106001600160401b0382111761068057604052565b61010081019081106001600160401b0382111761068057604052565b90601f801991011681019081106001600160401b0382111761068057604052565b9291926001600160401b03821161068057604051916124df601f8201601f191660200184612495565b829481845281830111610198578281602093846000960137010152565b90600182811c9216801561252c575b602083101461251657565b634e487b7160e01b600052602260045260246000fd5b91607f169161250b565b818110612541575050565b60008155600101612536565b61255781546124fc565b9081612561575050565b81601f600093116001146125745750555b565b8183526020832061259091601f0160051c810190600101612536565b8082528160208120915555565b156125a457565b60405162461bcd60e51b815260206004820152600f60248201526e55736572206e6f742065786973747360881b6044820152606490fd5b80548210156125f35760005260206000200190600090565b634e487b7160e01b600052603260045260246000fd5b60009291815491612619836124fc565b808352926001811690811561266f575060011461263557505050565b60009081526020812093945091925b838310612655575060209250010190565b600181602092949394548385870101520191019190612644565b915050602093945060ff929192191683830152151560051b010190565b9190601f811161269b57505050565b612572926000526020600020906020601f840160051c830193106126c7575b601f0160051c0190612536565b90915081906126ba565b9092916001600160401b038111610680576126f0816105af84546124fc565b6000601f82116001146127305781906127219394956000926127255750508160011b916000199060031b1c19161790565b9055565b0135905038806103b1565b601f198216948382526020822091805b87811061277857508360019596971061275e575b505050811b019055565b0135600019600384901b60f8161c19169055388080612754565b90926020600181928686013581550194019101612740565b9190918054600160401b811015610680576127b0916001820181556125db565b92909261189d57612572926126d1565b90918060409360208452816020850152848401376000828201840152601f01601f1916010190565b9181519283516001600160401b0381116106805761280a816105af84546124fc565b6020601f82116001146129045781600193926128419260209697986000926128985750508160011b916000199060031b1c19161790565b81555b019201519182516001600160401b03811161068057612867816105af84546124fc565b6020601f82116001146128a35781906127219394956000926128985750508160011b916000199060031b1c19161790565b0151905038806103b1565b601f1982169083600052806000209160005b8181106128ec575095836001959697106128d357505050811b019055565b015160001960f88460031b161c19169055388080612754565b9192602060018192868b0151815501940192016128b5565b601f1982169083600052806000209160005b818110612958575091839160209697986001969587951061293f575b505050811b018155612844565b015160001960f88460031b161c19169055388080612932565b9192602060018192868c015181550194019201612916565b1561297757565b60405162461bcd60e51b815260206004820152601760248201527f557365722049442063616e6e6f7420626520656d7074790000000000000000006044820152606490fd5b156129c357565b60405162461bcd60e51b815260206004820152600f60248201526e526f6c65206e6f742065786973747360881b6044820152606490fd5b15612a0157565b60405162461bcd60e51b815260206004820152600f60248201526e44617461206e6f742065786973747360881b6044820152606490fd5b15612a3f57565b60405162461bcd60e51b8152602060048201526013602482015272088c2e8c240deeedccae440dad2e6dac2e8c6d606b1b6044820152606490fd5b919091828114612b4c57612a8e83546124fc565b6001600160401b03811161068057612aaa816105af84546124fc565b600093601f8211600114612ae7576127219293948291600092612adc5750508160011b916000199060031b1c19161790565b0154905038806103b1565b845260208085208386529085209094601f198316815b818110612b3457509583600195969710612b1b57505050811b019055565b015460001960f88460031b161c19169055388080612754565b9192600180602092868b015481550194019201612afd565b509050565b60405190612b5e82612443565b60606020838281520152565b9060016020604051612b7b81612443565b612baa8195604051612b9181610a738185612609565b8352612ba36040518096819301612609565b0384612495565b0152565b8051156125f3576020019056fea2646970667358221220620f360a46df4db463cd5a88acb9db242b7d8393b55e8cf6b9e668cc74eba94764736f6c634300081d0033",
}

// ContractsABI is the input ABI used to generate the binding from.
// Deprecated: Use ContractsMetaData.ABI instead.
var ContractsABI = ContractsMetaData.ABI

// ContractsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ContractsMetaData.Bin instead.
var ContractsBin = ContractsMetaData.Bin

// DeployContracts deploys a new Ethereum contract, binding an instance of Contracts to it.
func DeployContracts(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Contracts, error) {
	parsed, err := ContractsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ContractsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Contracts{ContractsCaller: ContractsCaller{contract: contract}, ContractsTransactor: ContractsTransactor{contract: contract}, ContractsFilterer: ContractsFilterer{contract: contract}}, nil
}

// Contracts is an auto generated Go binding around an Ethereum contract.
type Contracts struct {
	ContractsCaller     // Read-only binding to the contract
	ContractsTransactor // Write-only binding to the contract
	ContractsFilterer   // Log filterer for contract events
}

// ContractsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContractsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContractsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContractsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContractsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContractsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContractsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContractsSession struct {
	Contract     *Contracts        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContractsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContractsCallerSession struct {
	Contract *ContractsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ContractsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContractsTransactorSession struct {
	Contract     *ContractsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ContractsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContractsRaw struct {
	Contract *Contracts // Generic contract binding to access the raw methods on
}

// ContractsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContractsCallerRaw struct {
	Contract *ContractsCaller // Generic read-only contract binding to access the raw methods on
}

// ContractsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContractsTransactorRaw struct {
	Contract *ContractsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContracts creates a new instance of Contracts, bound to a specific deployed contract.
func NewContracts(address common.Address, backend bind.ContractBackend) (*Contracts, error) {
	contract, err := bindContracts(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Contracts{ContractsCaller: ContractsCaller{contract: contract}, ContractsTransactor: ContractsTransactor{contract: contract}, ContractsFilterer: ContractsFilterer{contract: contract}}, nil
}

// NewContractsCaller creates a new read-only instance of Contracts, bound to a specific deployed contract.
func NewContractsCaller(address common.Address, caller bind.ContractCaller) (*ContractsCaller, error) {
	contract, err := bindContracts(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContractsCaller{contract: contract}, nil
}

// NewContractsTransactor creates a new write-only instance of Contracts, bound to a specific deployed contract.
func NewContractsTransactor(address common.Address, transactor bind.ContractTransactor) (*ContractsTransactor, error) {
	contract, err := bindContracts(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContractsTransactor{contract: contract}, nil
}

// NewContractsFilterer creates a new log filterer instance of Contracts, bound to a specific deployed contract.
func NewContractsFilterer(address common.Address, filterer bind.ContractFilterer) (*ContractsFilterer, error) {
	contract, err := bindContracts(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContractsFilterer{contract: contract}, nil
}

// bindContracts binds a generic wrapper to an already deployed contract.
func bindContracts(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ContractsMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Contracts *ContractsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Contracts.Contract.ContractsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Contracts *ContractsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Contracts.Contract.ContractsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Contracts *ContractsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Contracts.Contract.ContractsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Contracts *ContractsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Contracts.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Contracts *ContractsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Contracts.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Contracts *ContractsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Contracts.Contract.contract.Transact(opts, method, params...)
}

// GetData is a free data retrieval call binding the contract method 0xae55c888.
//
// Solidity: function getData(string _dataCID) view returns((string,uint256,string,string,string,string,string,string))
func (_Contracts *ContractsCaller) GetData(opts *bind.CallOpts, _dataCID string) (AcsRegistryData, error) {
	var out []interface{}
	err := _Contracts.contract.Call(opts, &out, "getData", _dataCID)

	if err != nil {
		return *new(AcsRegistryData), err
	}

	out0 := *abi.ConvertType(out[0], new(AcsRegistryData)).(*AcsRegistryData)

	return out0, err

}

// GetData is a free data retrieval call binding the contract method 0xae55c888.
//
// Solidity: function getData(string _dataCID) view returns((string,uint256,string,string,string,string,string,string))
func (_Contracts *ContractsSession) GetData(_dataCID string) (AcsRegistryData, error) {
	return _Contracts.Contract.GetData(&_Contracts.CallOpts, _dataCID)
}

// GetData is a free data retrieval call binding the contract method 0xae55c888.
//
// Solidity: function getData(string _dataCID) view returns((string,uint256,string,string,string,string,string,string))
func (_Contracts *ContractsCallerSession) GetData(_dataCID string) (AcsRegistryData, error) {
	return _Contracts.Contract.GetData(&_Contracts.CallOpts, _dataCID)
}

// GetDataOwner is a free data retrieval call binding the contract method 0xdba4d945.
//
// Solidity: function getDataOwner(string _dataCID) view returns(string)
func (_Contracts *ContractsCaller) GetDataOwner(opts *bind.CallOpts, _dataCID string) (string, error) {
	var out []interface{}
	err := _Contracts.contract.Call(opts, &out, "getDataOwner", _dataCID)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// GetDataOwner is a free data retrieval call binding the contract method 0xdba4d945.
//
// Solidity: function getDataOwner(string _dataCID) view returns(string)
func (_Contracts *ContractsSession) GetDataOwner(_dataCID string) (string, error) {
	return _Contracts.Contract.GetDataOwner(&_Contracts.CallOpts, _dataCID)
}

// GetDataOwner is a free data retrieval call binding the contract method 0xdba4d945.
//
// Solidity: function getDataOwner(string _dataCID) view returns(string)
func (_Contracts *ContractsCallerSession) GetDataOwner(_dataCID string) (string, error) {
	return _Contracts.Contract.GetDataOwner(&_Contracts.CallOpts, _dataCID)
}

// GetPermission is a free data retrieval call binding the contract method 0xddc46c62.
//
// Solidity: function getPermission(string _permissionID) view returns((string,string))
func (_Contracts *ContractsCaller) GetPermission(opts *bind.CallOpts, _permissionID string) (AcsRegistryPermission, error) {
	var out []interface{}
	err := _Contracts.contract.Call(opts, &out, "getPermission", _permissionID)

	if err != nil {
		return *new(AcsRegistryPermission), err
	}

	out0 := *abi.ConvertType(out[0], new(AcsRegistryPermission)).(*AcsRegistryPermission)

	return out0, err

}

// GetPermission is a free data retrieval call binding the contract method 0xddc46c62.
//
// Solidity: function getPermission(string _permissionID) view returns((string,string))
func (_Contracts *ContractsSession) GetPermission(_permissionID string) (AcsRegistryPermission, error) {
	return _Contracts.Contract.GetPermission(&_Contracts.CallOpts, _permissionID)
}

// GetPermission is a free data retrieval call binding the contract method 0xddc46c62.
//
// Solidity: function getPermission(string _permissionID) view returns((string,string))
func (_Contracts *ContractsCallerSession) GetPermission(_permissionID string) (AcsRegistryPermission, error) {
	return _Contracts.Contract.GetPermission(&_Contracts.CallOpts, _permissionID)
}

// GetRole is a free data retrieval call binding the contract method 0x6e9067fb.
//
// Solidity: function getRole(string _roleID) view returns((string,string))
func (_Contracts *ContractsCaller) GetRole(opts *bind.CallOpts, _roleID string) (AcsRegistryRole, error) {
	var out []interface{}
	err := _Contracts.contract.Call(opts, &out, "getRole", _roleID)

	if err != nil {
		return *new(AcsRegistryRole), err
	}

	out0 := *abi.ConvertType(out[0], new(AcsRegistryRole)).(*AcsRegistryRole)

	return out0, err

}

// GetRole is a free data retrieval call binding the contract method 0x6e9067fb.
//
// Solidity: function getRole(string _roleID) view returns((string,string))
func (_Contracts *ContractsSession) GetRole(_roleID string) (AcsRegistryRole, error) {
	return _Contracts.Contract.GetRole(&_Contracts.CallOpts, _roleID)
}

// GetRole is a free data retrieval call binding the contract method 0x6e9067fb.
//
// Solidity: function getRole(string _roleID) view returns((string,string))
func (_Contracts *ContractsCallerSession) GetRole(_roleID string) (AcsRegistryRole, error) {
	return _Contracts.Contract.GetRole(&_Contracts.CallOpts, _roleID)
}

// GetUser is a free data retrieval call binding the contract method 0x31feb671.
//
// Solidity: function getUser(string _userID) view returns((string,string,string,string[],string,string))
func (_Contracts *ContractsCaller) GetUser(opts *bind.CallOpts, _userID string) (AcsRegistryUser, error) {
	var out []interface{}
	err := _Contracts.contract.Call(opts, &out, "getUser", _userID)

	if err != nil {
		return *new(AcsRegistryUser), err
	}

	out0 := *abi.ConvertType(out[0], new(AcsRegistryUser)).(*AcsRegistryUser)

	return out0, err

}

// GetUser is a free data retrieval call binding the contract method 0x31feb671.
//
// Solidity: function getUser(string _userID) view returns((string,string,string,string[],string,string))
func (_Contracts *ContractsSession) GetUser(_userID string) (AcsRegistryUser, error) {
	return _Contracts.Contract.GetUser(&_Contracts.CallOpts, _userID)
}

// GetUser is a free data retrieval call binding the contract method 0x31feb671.
//
// Solidity: function getUser(string _userID) view returns((string,string,string,string[],string,string))
func (_Contracts *ContractsCallerSession) GetUser(_userID string) (AcsRegistryUser, error) {
	return _Contracts.Contract.GetUser(&_Contracts.CallOpts, _userID)
}

// DeleteData is a paid mutator transaction binding the contract method 0xa69ea63c.
//
// Solidity: function deleteData(string _dataOwner, string _dataCID) returns()
func (_Contracts *ContractsTransactor) DeleteData(opts *bind.TransactOpts, _dataOwner string, _dataCID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "deleteData", _dataOwner, _dataCID)
}

// DeleteData is a paid mutator transaction binding the contract method 0xa69ea63c.
//
// Solidity: function deleteData(string _dataOwner, string _dataCID) returns()
func (_Contracts *ContractsSession) DeleteData(_dataOwner string, _dataCID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteData(&_Contracts.TransactOpts, _dataOwner, _dataCID)
}

// DeleteData is a paid mutator transaction binding the contract method 0xa69ea63c.
//
// Solidity: function deleteData(string _dataOwner, string _dataCID) returns()
func (_Contracts *ContractsTransactorSession) DeleteData(_dataOwner string, _dataCID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteData(&_Contracts.TransactOpts, _dataOwner, _dataCID)
}

// DeleteRole is a paid mutator transaction binding the contract method 0xf29f968d.
//
// Solidity: function deleteRole(string _roleID) returns()
func (_Contracts *ContractsTransactor) DeleteRole(opts *bind.TransactOpts, _roleID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "deleteRole", _roleID)
}

// DeleteRole is a paid mutator transaction binding the contract method 0xf29f968d.
//
// Solidity: function deleteRole(string _roleID) returns()
func (_Contracts *ContractsSession) DeleteRole(_roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteRole(&_Contracts.TransactOpts, _roleID)
}

// DeleteRole is a paid mutator transaction binding the contract method 0xf29f968d.
//
// Solidity: function deleteRole(string _roleID) returns()
func (_Contracts *ContractsTransactorSession) DeleteRole(_roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteRole(&_Contracts.TransactOpts, _roleID)
}

// DeleteUser is a paid mutator transaction binding the contract method 0xd3695161.
//
// Solidity: function deleteUser(string _userID) returns()
func (_Contracts *ContractsTransactor) DeleteUser(opts *bind.TransactOpts, _userID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "deleteUser", _userID)
}

// DeleteUser is a paid mutator transaction binding the contract method 0xd3695161.
//
// Solidity: function deleteUser(string _userID) returns()
func (_Contracts *ContractsSession) DeleteUser(_userID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteUser(&_Contracts.TransactOpts, _userID)
}

// DeleteUser is a paid mutator transaction binding the contract method 0xd3695161.
//
// Solidity: function deleteUser(string _userID) returns()
func (_Contracts *ContractsTransactorSession) DeleteUser(_userID string) (*types.Transaction, error) {
	return _Contracts.Contract.DeleteUser(&_Contracts.TransactOpts, _userID)
}

// GrantPermission is a paid mutator transaction binding the contract method 0x2808235f.
//
// Solidity: function grantPermission(string _permissionID, string _permissionList) returns()
func (_Contracts *ContractsTransactor) GrantPermission(opts *bind.TransactOpts, _permissionID string, _permissionList string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "grantPermission", _permissionID, _permissionList)
}

// GrantPermission is a paid mutator transaction binding the contract method 0x2808235f.
//
// Solidity: function grantPermission(string _permissionID, string _permissionList) returns()
func (_Contracts *ContractsSession) GrantPermission(_permissionID string, _permissionList string) (*types.Transaction, error) {
	return _Contracts.Contract.GrantPermission(&_Contracts.TransactOpts, _permissionID, _permissionList)
}

// GrantPermission is a paid mutator transaction binding the contract method 0x2808235f.
//
// Solidity: function grantPermission(string _permissionID, string _permissionList) returns()
func (_Contracts *ContractsTransactorSession) GrantPermission(_permissionID string, _permissionList string) (*types.Transaction, error) {
	return _Contracts.Contract.GrantPermission(&_Contracts.TransactOpts, _permissionID, _permissionList)
}

// GrantRole is a paid mutator transaction binding the contract method 0x03fe93fe.
//
// Solidity: function grantRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsTransactor) GrantRole(opts *bind.TransactOpts, _userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "grantRole", _userID, _roleID)
}

// GrantRole is a paid mutator transaction binding the contract method 0x03fe93fe.
//
// Solidity: function grantRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsSession) GrantRole(_userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.GrantRole(&_Contracts.TransactOpts, _userID, _roleID)
}

// GrantRole is a paid mutator transaction binding the contract method 0x03fe93fe.
//
// Solidity: function grantRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsTransactorSession) GrantRole(_userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.GrantRole(&_Contracts.TransactOpts, _userID, _roleID)
}

// PutData is a paid mutator transaction binding the contract method 0xeb3a8b4b.
//
// Solidity: function putData(string _dataName, uint256 _dataSize, string _dataOwner, string _dataCID, string _dataEncryption, string _dataCreation, string _dataRevision, string _dataMeta) returns()
func (_Contracts *ContractsTransactor) PutData(opts *bind.TransactOpts, _dataName string, _dataSize *big.Int, _dataOwner string, _dataCID string, _dataEncryption string, _dataCreation string, _dataRevision string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "putData", _dataName, _dataSize, _dataOwner, _dataCID, _dataEncryption, _dataCreation, _dataRevision, _dataMeta)
}

// PutData is a paid mutator transaction binding the contract method 0xeb3a8b4b.
//
// Solidity: function putData(string _dataName, uint256 _dataSize, string _dataOwner, string _dataCID, string _dataEncryption, string _dataCreation, string _dataRevision, string _dataMeta) returns()
func (_Contracts *ContractsSession) PutData(_dataName string, _dataSize *big.Int, _dataOwner string, _dataCID string, _dataEncryption string, _dataCreation string, _dataRevision string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.Contract.PutData(&_Contracts.TransactOpts, _dataName, _dataSize, _dataOwner, _dataCID, _dataEncryption, _dataCreation, _dataRevision, _dataMeta)
}

// PutData is a paid mutator transaction binding the contract method 0xeb3a8b4b.
//
// Solidity: function putData(string _dataName, uint256 _dataSize, string _dataOwner, string _dataCID, string _dataEncryption, string _dataCreation, string _dataRevision, string _dataMeta) returns()
func (_Contracts *ContractsTransactorSession) PutData(_dataName string, _dataSize *big.Int, _dataOwner string, _dataCID string, _dataEncryption string, _dataCreation string, _dataRevision string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.Contract.PutData(&_Contracts.TransactOpts, _dataName, _dataSize, _dataOwner, _dataCID, _dataEncryption, _dataCreation, _dataRevision, _dataMeta)
}

// RegisterRole is a paid mutator transaction binding the contract method 0x0b1a5625.
//
// Solidity: function registerRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsTransactor) RegisterRole(opts *bind.TransactOpts, _roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "registerRole", _roleID, _roleName)
}

// RegisterRole is a paid mutator transaction binding the contract method 0x0b1a5625.
//
// Solidity: function registerRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsSession) RegisterRole(_roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.Contract.RegisterRole(&_Contracts.TransactOpts, _roleID, _roleName)
}

// RegisterRole is a paid mutator transaction binding the contract method 0x0b1a5625.
//
// Solidity: function registerRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsTransactorSession) RegisterRole(_roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.Contract.RegisterRole(&_Contracts.TransactOpts, _roleID, _roleName)
}

// RegisterUser is a paid mutator transaction binding the contract method 0x7832a0d1.
//
// Solidity: function registerUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsTransactor) RegisterUser(opts *bind.TransactOpts, _userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "registerUser", _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// RegisterUser is a paid mutator transaction binding the contract method 0x7832a0d1.
//
// Solidity: function registerUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsSession) RegisterUser(_userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.Contract.RegisterUser(&_Contracts.TransactOpts, _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// RegisterUser is a paid mutator transaction binding the contract method 0x7832a0d1.
//
// Solidity: function registerUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsTransactorSession) RegisterUser(_userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.Contract.RegisterUser(&_Contracts.TransactOpts, _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// RevokePermission is a paid mutator transaction binding the contract method 0x02f9888e.
//
// Solidity: function revokePermission(string _permissionID) returns()
func (_Contracts *ContractsTransactor) RevokePermission(opts *bind.TransactOpts, _permissionID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "revokePermission", _permissionID)
}

// RevokePermission is a paid mutator transaction binding the contract method 0x02f9888e.
//
// Solidity: function revokePermission(string _permissionID) returns()
func (_Contracts *ContractsSession) RevokePermission(_permissionID string) (*types.Transaction, error) {
	return _Contracts.Contract.RevokePermission(&_Contracts.TransactOpts, _permissionID)
}

// RevokePermission is a paid mutator transaction binding the contract method 0x02f9888e.
//
// Solidity: function revokePermission(string _permissionID) returns()
func (_Contracts *ContractsTransactorSession) RevokePermission(_permissionID string) (*types.Transaction, error) {
	return _Contracts.Contract.RevokePermission(&_Contracts.TransactOpts, _permissionID)
}

// RevokeRole is a paid mutator transaction binding the contract method 0x5884c96b.
//
// Solidity: function revokeRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsTransactor) RevokeRole(opts *bind.TransactOpts, _userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "revokeRole", _userID, _roleID)
}

// RevokeRole is a paid mutator transaction binding the contract method 0x5884c96b.
//
// Solidity: function revokeRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsSession) RevokeRole(_userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.RevokeRole(&_Contracts.TransactOpts, _userID, _roleID)
}

// RevokeRole is a paid mutator transaction binding the contract method 0x5884c96b.
//
// Solidity: function revokeRole(string _userID, string _roleID) returns()
func (_Contracts *ContractsTransactorSession) RevokeRole(_userID string, _roleID string) (*types.Transaction, error) {
	return _Contracts.Contract.RevokeRole(&_Contracts.TransactOpts, _userID, _roleID)
}

// TransferData is a paid mutator transaction binding the contract method 0xd676260f.
//
// Solidity: function transferData(string _dataOwner, string _dataCID, string _newOwner) returns()
func (_Contracts *ContractsTransactor) TransferData(opts *bind.TransactOpts, _dataOwner string, _dataCID string, _newOwner string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "transferData", _dataOwner, _dataCID, _newOwner)
}

// TransferData is a paid mutator transaction binding the contract method 0xd676260f.
//
// Solidity: function transferData(string _dataOwner, string _dataCID, string _newOwner) returns()
func (_Contracts *ContractsSession) TransferData(_dataOwner string, _dataCID string, _newOwner string) (*types.Transaction, error) {
	return _Contracts.Contract.TransferData(&_Contracts.TransactOpts, _dataOwner, _dataCID, _newOwner)
}

// TransferData is a paid mutator transaction binding the contract method 0xd676260f.
//
// Solidity: function transferData(string _dataOwner, string _dataCID, string _newOwner) returns()
func (_Contracts *ContractsTransactorSession) TransferData(_dataOwner string, _dataCID string, _newOwner string) (*types.Transaction, error) {
	return _Contracts.Contract.TransferData(&_Contracts.TransactOpts, _dataOwner, _dataCID, _newOwner)
}

// UpdateData is a paid mutator transaction binding the contract method 0x55995dba.
//
// Solidity: function updateData(string _dataOwner, string _dataCID, string _dataMeta) returns()
func (_Contracts *ContractsTransactor) UpdateData(opts *bind.TransactOpts, _dataOwner string, _dataCID string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "updateData", _dataOwner, _dataCID, _dataMeta)
}

// UpdateData is a paid mutator transaction binding the contract method 0x55995dba.
//
// Solidity: function updateData(string _dataOwner, string _dataCID, string _dataMeta) returns()
func (_Contracts *ContractsSession) UpdateData(_dataOwner string, _dataCID string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateData(&_Contracts.TransactOpts, _dataOwner, _dataCID, _dataMeta)
}

// UpdateData is a paid mutator transaction binding the contract method 0x55995dba.
//
// Solidity: function updateData(string _dataOwner, string _dataCID, string _dataMeta) returns()
func (_Contracts *ContractsTransactorSession) UpdateData(_dataOwner string, _dataCID string, _dataMeta string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateData(&_Contracts.TransactOpts, _dataOwner, _dataCID, _dataMeta)
}

// UpdateRole is a paid mutator transaction binding the contract method 0x2c8b0766.
//
// Solidity: function updateRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsTransactor) UpdateRole(opts *bind.TransactOpts, _roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "updateRole", _roleID, _roleName)
}

// UpdateRole is a paid mutator transaction binding the contract method 0x2c8b0766.
//
// Solidity: function updateRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsSession) UpdateRole(_roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateRole(&_Contracts.TransactOpts, _roleID, _roleName)
}

// UpdateRole is a paid mutator transaction binding the contract method 0x2c8b0766.
//
// Solidity: function updateRole(string _roleID, string _roleName) returns()
func (_Contracts *ContractsTransactorSession) UpdateRole(_roleID string, _roleName string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateRole(&_Contracts.TransactOpts, _roleID, _roleName)
}

// UpdateUser is a paid mutator transaction binding the contract method 0x15f5744a.
//
// Solidity: function updateUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsTransactor) UpdateUser(opts *bind.TransactOpts, _userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.contract.Transact(opts, "updateUser", _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// UpdateUser is a paid mutator transaction binding the contract method 0x15f5744a.
//
// Solidity: function updateUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsSession) UpdateUser(_userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateUser(&_Contracts.TransactOpts, _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// UpdateUser is a paid mutator transaction binding the contract method 0x15f5744a.
//
// Solidity: function updateUser(string _userID, string _userName, string _userDID, string _userRole, string _userAddr, string _userContact) returns()
func (_Contracts *ContractsTransactorSession) UpdateUser(_userID string, _userName string, _userDID string, _userRole string, _userAddr string, _userContact string) (*types.Transaction, error) {
	return _Contracts.Contract.UpdateUser(&_Contracts.TransactOpts, _userID, _userName, _userDID, _userRole, _userAddr, _userContact)
}

// ContractsDataDeletedIterator is returned from FilterDataDeleted and is used to iterate over the raw logs and unpacked data for DataDeleted events raised by the Contracts contract.
type ContractsDataDeletedIterator struct {
	Event *ContractsDataDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsDataDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsDataDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsDataDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsDataDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsDataDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsDataDeleted represents a DataDeleted event raised by the Contracts contract.
type ContractsDataDeleted struct {
	Cid [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDataDeleted is a free log retrieval operation binding the contract event 0x5236602858fa598e0b1c0f4eab28a46d135d76a3a28731d8dca95bc52c91bc33.
//
// Solidity: event DataDeleted(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) FilterDataDeleted(opts *bind.FilterOpts, cid [][32]byte) (*ContractsDataDeletedIterator, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "DataDeleted", cidRule)
	if err != nil {
		return nil, err
	}
	return &ContractsDataDeletedIterator{contract: _Contracts.contract, event: "DataDeleted", logs: logs, sub: sub}, nil
}

// WatchDataDeleted is a free log subscription operation binding the contract event 0x5236602858fa598e0b1c0f4eab28a46d135d76a3a28731d8dca95bc52c91bc33.
//
// Solidity: event DataDeleted(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) WatchDataDeleted(opts *bind.WatchOpts, sink chan<- *ContractsDataDeleted, cid [][32]byte) (event.Subscription, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "DataDeleted", cidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsDataDeleted)
				if err := _Contracts.contract.UnpackLog(event, "DataDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataDeleted is a log parse operation binding the contract event 0x5236602858fa598e0b1c0f4eab28a46d135d76a3a28731d8dca95bc52c91bc33.
//
// Solidity: event DataDeleted(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) ParseDataDeleted(log types.Log) (*ContractsDataDeleted, error) {
	event := new(ContractsDataDeleted)
	if err := _Contracts.contract.UnpackLog(event, "DataDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsDataPutIterator is returned from FilterDataPut and is used to iterate over the raw logs and unpacked data for DataPut events raised by the Contracts contract.
type ContractsDataPutIterator struct {
	Event *ContractsDataPut // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsDataPutIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsDataPut)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsDataPut)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsDataPutIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsDataPutIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsDataPut represents a DataPut event raised by the Contracts contract.
type ContractsDataPut struct {
	Cid [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDataPut is a free log retrieval operation binding the contract event 0x9e8a898414956758234305855c8bb7a18a44a908dab1c20f1da8bb55ffa4fce8.
//
// Solidity: event DataPut(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) FilterDataPut(opts *bind.FilterOpts, cid [][32]byte) (*ContractsDataPutIterator, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "DataPut", cidRule)
	if err != nil {
		return nil, err
	}
	return &ContractsDataPutIterator{contract: _Contracts.contract, event: "DataPut", logs: logs, sub: sub}, nil
}

// WatchDataPut is a free log subscription operation binding the contract event 0x9e8a898414956758234305855c8bb7a18a44a908dab1c20f1da8bb55ffa4fce8.
//
// Solidity: event DataPut(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) WatchDataPut(opts *bind.WatchOpts, sink chan<- *ContractsDataPut, cid [][32]byte) (event.Subscription, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "DataPut", cidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsDataPut)
				if err := _Contracts.contract.UnpackLog(event, "DataPut", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataPut is a log parse operation binding the contract event 0x9e8a898414956758234305855c8bb7a18a44a908dab1c20f1da8bb55ffa4fce8.
//
// Solidity: event DataPut(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) ParseDataPut(log types.Log) (*ContractsDataPut, error) {
	event := new(ContractsDataPut)
	if err := _Contracts.contract.UnpackLog(event, "DataPut", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsDataTransferredIterator is returned from FilterDataTransferred and is used to iterate over the raw logs and unpacked data for DataTransferred events raised by the Contracts contract.
type ContractsDataTransferredIterator struct {
	Event *ContractsDataTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsDataTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsDataTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsDataTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsDataTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsDataTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsDataTransferred represents a DataTransferred event raised by the Contracts contract.
type ContractsDataTransferred struct {
	Cid      [32]byte
	NewOwner string
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDataTransferred is a free log retrieval operation binding the contract event 0x7e3b036b87e87f04c2fa478ec61db001b3577118d4e59ee42b7f073e42b887f7.
//
// Solidity: event DataTransferred(bytes32 indexed cid, string newOwner)
func (_Contracts *ContractsFilterer) FilterDataTransferred(opts *bind.FilterOpts, cid [][32]byte) (*ContractsDataTransferredIterator, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "DataTransferred", cidRule)
	if err != nil {
		return nil, err
	}
	return &ContractsDataTransferredIterator{contract: _Contracts.contract, event: "DataTransferred", logs: logs, sub: sub}, nil
}

// WatchDataTransferred is a free log subscription operation binding the contract event 0x7e3b036b87e87f04c2fa478ec61db001b3577118d4e59ee42b7f073e42b887f7.
//
// Solidity: event DataTransferred(bytes32 indexed cid, string newOwner)
func (_Contracts *ContractsFilterer) WatchDataTransferred(opts *bind.WatchOpts, sink chan<- *ContractsDataTransferred, cid [][32]byte) (event.Subscription, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "DataTransferred", cidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsDataTransferred)
				if err := _Contracts.contract.UnpackLog(event, "DataTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataTransferred is a log parse operation binding the contract event 0x7e3b036b87e87f04c2fa478ec61db001b3577118d4e59ee42b7f073e42b887f7.
//
// Solidity: event DataTransferred(bytes32 indexed cid, string newOwner)
func (_Contracts *ContractsFilterer) ParseDataTransferred(log types.Log) (*ContractsDataTransferred, error) {
	event := new(ContractsDataTransferred)
	if err := _Contracts.contract.UnpackLog(event, "DataTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsDataUpdatedIterator is returned from FilterDataUpdated and is used to iterate over the raw logs and unpacked data for DataUpdated events raised by the Contracts contract.
type ContractsDataUpdatedIterator struct {
	Event *ContractsDataUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsDataUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsDataUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsDataUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsDataUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsDataUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsDataUpdated represents a DataUpdated event raised by the Contracts contract.
type ContractsDataUpdated struct {
	Cid [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDataUpdated is a free log retrieval operation binding the contract event 0x3127c1223c3e044893fdbef142783b113140774723e7a54693844985a4f8fc06.
//
// Solidity: event DataUpdated(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) FilterDataUpdated(opts *bind.FilterOpts, cid [][32]byte) (*ContractsDataUpdatedIterator, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "DataUpdated", cidRule)
	if err != nil {
		return nil, err
	}
	return &ContractsDataUpdatedIterator{contract: _Contracts.contract, event: "DataUpdated", logs: logs, sub: sub}, nil
}

// WatchDataUpdated is a free log subscription operation binding the contract event 0x3127c1223c3e044893fdbef142783b113140774723e7a54693844985a4f8fc06.
//
// Solidity: event DataUpdated(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) WatchDataUpdated(opts *bind.WatchOpts, sink chan<- *ContractsDataUpdated, cid [][32]byte) (event.Subscription, error) {

	var cidRule []interface{}
	for _, cidItem := range cid {
		cidRule = append(cidRule, cidItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "DataUpdated", cidRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsDataUpdated)
				if err := _Contracts.contract.UnpackLog(event, "DataUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDataUpdated is a log parse operation binding the contract event 0x3127c1223c3e044893fdbef142783b113140774723e7a54693844985a4f8fc06.
//
// Solidity: event DataUpdated(bytes32 indexed cid)
func (_Contracts *ContractsFilterer) ParseDataUpdated(log types.Log) (*ContractsDataUpdated, error) {
	event := new(ContractsDataUpdated)
	if err := _Contracts.contract.UnpackLog(event, "DataUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsPermissionGrantedIterator is returned from FilterPermissionGranted and is used to iterate over the raw logs and unpacked data for PermissionGranted events raised by the Contracts contract.
type ContractsPermissionGrantedIterator struct {
	Event *ContractsPermissionGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsPermissionGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsPermissionGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsPermissionGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsPermissionGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsPermissionGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsPermissionGranted represents a PermissionGranted event raised by the Contracts contract.
type ContractsPermissionGranted struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPermissionGranted is a free log retrieval operation binding the contract event 0xa3d61b9cdf744675cae28d310353843537e9170210b3511e84bfe222b01b40ee.
//
// Solidity: event PermissionGranted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterPermissionGranted(opts *bind.FilterOpts, id [][32]byte) (*ContractsPermissionGrantedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "PermissionGranted", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsPermissionGrantedIterator{contract: _Contracts.contract, event: "PermissionGranted", logs: logs, sub: sub}, nil
}

// WatchPermissionGranted is a free log subscription operation binding the contract event 0xa3d61b9cdf744675cae28d310353843537e9170210b3511e84bfe222b01b40ee.
//
// Solidity: event PermissionGranted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchPermissionGranted(opts *bind.WatchOpts, sink chan<- *ContractsPermissionGranted, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "PermissionGranted", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsPermissionGranted)
				if err := _Contracts.contract.UnpackLog(event, "PermissionGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePermissionGranted is a log parse operation binding the contract event 0xa3d61b9cdf744675cae28d310353843537e9170210b3511e84bfe222b01b40ee.
//
// Solidity: event PermissionGranted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParsePermissionGranted(log types.Log) (*ContractsPermissionGranted, error) {
	event := new(ContractsPermissionGranted)
	if err := _Contracts.contract.UnpackLog(event, "PermissionGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsPermissionRevokedIterator is returned from FilterPermissionRevoked and is used to iterate over the raw logs and unpacked data for PermissionRevoked events raised by the Contracts contract.
type ContractsPermissionRevokedIterator struct {
	Event *ContractsPermissionRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsPermissionRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsPermissionRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsPermissionRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsPermissionRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsPermissionRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsPermissionRevoked represents a PermissionRevoked event raised by the Contracts contract.
type ContractsPermissionRevoked struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPermissionRevoked is a free log retrieval operation binding the contract event 0x4e675315fe96944f365f4da1440d600a41b31e9484ae6cc0fd9fc7cd4773af67.
//
// Solidity: event PermissionRevoked(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterPermissionRevoked(opts *bind.FilterOpts, id [][32]byte) (*ContractsPermissionRevokedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "PermissionRevoked", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsPermissionRevokedIterator{contract: _Contracts.contract, event: "PermissionRevoked", logs: logs, sub: sub}, nil
}

// WatchPermissionRevoked is a free log subscription operation binding the contract event 0x4e675315fe96944f365f4da1440d600a41b31e9484ae6cc0fd9fc7cd4773af67.
//
// Solidity: event PermissionRevoked(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchPermissionRevoked(opts *bind.WatchOpts, sink chan<- *ContractsPermissionRevoked, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "PermissionRevoked", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsPermissionRevoked)
				if err := _Contracts.contract.UnpackLog(event, "PermissionRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePermissionRevoked is a log parse operation binding the contract event 0x4e675315fe96944f365f4da1440d600a41b31e9484ae6cc0fd9fc7cd4773af67.
//
// Solidity: event PermissionRevoked(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParsePermissionRevoked(log types.Log) (*ContractsPermissionRevoked, error) {
	event := new(ContractsPermissionRevoked)
	if err := _Contracts.contract.UnpackLog(event, "PermissionRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsRoleDeletedIterator is returned from FilterRoleDeleted and is used to iterate over the raw logs and unpacked data for RoleDeleted events raised by the Contracts contract.
type ContractsRoleDeletedIterator struct {
	Event *ContractsRoleDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsRoleDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsRoleDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsRoleDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsRoleDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsRoleDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsRoleDeleted represents a RoleDeleted event raised by the Contracts contract.
type ContractsRoleDeleted struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterRoleDeleted is a free log retrieval operation binding the contract event 0xef9f0985bfd169b17c43b61ad1e35c0c7fe75dd675fb0fe8d914a12fd12631c6.
//
// Solidity: event RoleDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterRoleDeleted(opts *bind.FilterOpts, id [][32]byte) (*ContractsRoleDeletedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "RoleDeleted", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsRoleDeletedIterator{contract: _Contracts.contract, event: "RoleDeleted", logs: logs, sub: sub}, nil
}

// WatchRoleDeleted is a free log subscription operation binding the contract event 0xef9f0985bfd169b17c43b61ad1e35c0c7fe75dd675fb0fe8d914a12fd12631c6.
//
// Solidity: event RoleDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchRoleDeleted(opts *bind.WatchOpts, sink chan<- *ContractsRoleDeleted, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "RoleDeleted", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsRoleDeleted)
				if err := _Contracts.contract.UnpackLog(event, "RoleDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleDeleted is a log parse operation binding the contract event 0xef9f0985bfd169b17c43b61ad1e35c0c7fe75dd675fb0fe8d914a12fd12631c6.
//
// Solidity: event RoleDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseRoleDeleted(log types.Log) (*ContractsRoleDeleted, error) {
	event := new(ContractsRoleDeleted)
	if err := _Contracts.contract.UnpackLog(event, "RoleDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the Contracts contract.
type ContractsRoleGrantedIterator struct {
	Event *ContractsRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsRoleGranted represents a RoleGranted event raised by the Contracts contract.
type ContractsRoleGranted struct {
	Id     [32]byte
	RoleID string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x960490bb96f8fde4056c4450ff105ec595dd2eabea364f74759e0f5ea65f88e1.
//
// Solidity: event RoleGranted(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) FilterRoleGranted(opts *bind.FilterOpts, id [][32]byte) (*ContractsRoleGrantedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "RoleGranted", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsRoleGrantedIterator{contract: _Contracts.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x960490bb96f8fde4056c4450ff105ec595dd2eabea364f74759e0f5ea65f88e1.
//
// Solidity: event RoleGranted(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *ContractsRoleGranted, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "RoleGranted", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsRoleGranted)
				if err := _Contracts.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x960490bb96f8fde4056c4450ff105ec595dd2eabea364f74759e0f5ea65f88e1.
//
// Solidity: event RoleGranted(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) ParseRoleGranted(log types.Log) (*ContractsRoleGranted, error) {
	event := new(ContractsRoleGranted)
	if err := _Contracts.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsRoleRegisteredIterator is returned from FilterRoleRegistered and is used to iterate over the raw logs and unpacked data for RoleRegistered events raised by the Contracts contract.
type ContractsRoleRegisteredIterator struct {
	Event *ContractsRoleRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsRoleRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsRoleRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsRoleRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsRoleRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsRoleRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsRoleRegistered represents a RoleRegistered event raised by the Contracts contract.
type ContractsRoleRegistered struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterRoleRegistered is a free log retrieval operation binding the contract event 0x4351843977dda133afcc2219e41c320efe8742e2a678b5db94b863e08d199394.
//
// Solidity: event RoleRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterRoleRegistered(opts *bind.FilterOpts, id [][32]byte) (*ContractsRoleRegisteredIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "RoleRegistered", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsRoleRegisteredIterator{contract: _Contracts.contract, event: "RoleRegistered", logs: logs, sub: sub}, nil
}

// WatchRoleRegistered is a free log subscription operation binding the contract event 0x4351843977dda133afcc2219e41c320efe8742e2a678b5db94b863e08d199394.
//
// Solidity: event RoleRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchRoleRegistered(opts *bind.WatchOpts, sink chan<- *ContractsRoleRegistered, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "RoleRegistered", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsRoleRegistered)
				if err := _Contracts.contract.UnpackLog(event, "RoleRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRegistered is a log parse operation binding the contract event 0x4351843977dda133afcc2219e41c320efe8742e2a678b5db94b863e08d199394.
//
// Solidity: event RoleRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseRoleRegistered(log types.Log) (*ContractsRoleRegistered, error) {
	event := new(ContractsRoleRegistered)
	if err := _Contracts.contract.UnpackLog(event, "RoleRegistered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the Contracts contract.
type ContractsRoleRevokedIterator struct {
	Event *ContractsRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsRoleRevoked represents a RoleRevoked event raised by the Contracts contract.
type ContractsRoleRevoked struct {
	Id     [32]byte
	RoleID string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0x94a5751b72e16c553db8e06715db8751e285f76cb50d9275da249f2f30b3b3bf.
//
// Solidity: event RoleRevoked(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) FilterRoleRevoked(opts *bind.FilterOpts, id [][32]byte) (*ContractsRoleRevokedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "RoleRevoked", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsRoleRevokedIterator{contract: _Contracts.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0x94a5751b72e16c553db8e06715db8751e285f76cb50d9275da249f2f30b3b3bf.
//
// Solidity: event RoleRevoked(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *ContractsRoleRevoked, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "RoleRevoked", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsRoleRevoked)
				if err := _Contracts.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0x94a5751b72e16c553db8e06715db8751e285f76cb50d9275da249f2f30b3b3bf.
//
// Solidity: event RoleRevoked(bytes32 indexed id, string roleID)
func (_Contracts *ContractsFilterer) ParseRoleRevoked(log types.Log) (*ContractsRoleRevoked, error) {
	event := new(ContractsRoleRevoked)
	if err := _Contracts.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsRoleUpdatedIterator is returned from FilterRoleUpdated and is used to iterate over the raw logs and unpacked data for RoleUpdated events raised by the Contracts contract.
type ContractsRoleUpdatedIterator struct {
	Event *ContractsRoleUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsRoleUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsRoleUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsRoleUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsRoleUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsRoleUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsRoleUpdated represents a RoleUpdated event raised by the Contracts contract.
type ContractsRoleUpdated struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterRoleUpdated is a free log retrieval operation binding the contract event 0x5e293651729dbde44d92d54c33bc997eac7c3742e57f302f71336f176a39e4ab.
//
// Solidity: event RoleUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterRoleUpdated(opts *bind.FilterOpts, id [][32]byte) (*ContractsRoleUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "RoleUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsRoleUpdatedIterator{contract: _Contracts.contract, event: "RoleUpdated", logs: logs, sub: sub}, nil
}

// WatchRoleUpdated is a free log subscription operation binding the contract event 0x5e293651729dbde44d92d54c33bc997eac7c3742e57f302f71336f176a39e4ab.
//
// Solidity: event RoleUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchRoleUpdated(opts *bind.WatchOpts, sink chan<- *ContractsRoleUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "RoleUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsRoleUpdated)
				if err := _Contracts.contract.UnpackLog(event, "RoleUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleUpdated is a log parse operation binding the contract event 0x5e293651729dbde44d92d54c33bc997eac7c3742e57f302f71336f176a39e4ab.
//
// Solidity: event RoleUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseRoleUpdated(log types.Log) (*ContractsRoleUpdated, error) {
	event := new(ContractsRoleUpdated)
	if err := _Contracts.contract.UnpackLog(event, "RoleUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsUserDeletedIterator is returned from FilterUserDeleted and is used to iterate over the raw logs and unpacked data for UserDeleted events raised by the Contracts contract.
type ContractsUserDeletedIterator struct {
	Event *ContractsUserDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsUserDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsUserDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsUserDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsUserDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsUserDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsUserDeleted represents a UserDeleted event raised by the Contracts contract.
type ContractsUserDeleted struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUserDeleted is a free log retrieval operation binding the contract event 0xc26eb30613e535870aeacfc24e58a8fb60e992f0d8bfe04ec9c98db26b53c5e5.
//
// Solidity: event UserDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterUserDeleted(opts *bind.FilterOpts, id [][32]byte) (*ContractsUserDeletedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "UserDeleted", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsUserDeletedIterator{contract: _Contracts.contract, event: "UserDeleted", logs: logs, sub: sub}, nil
}

// WatchUserDeleted is a free log subscription operation binding the contract event 0xc26eb30613e535870aeacfc24e58a8fb60e992f0d8bfe04ec9c98db26b53c5e5.
//
// Solidity: event UserDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchUserDeleted(opts *bind.WatchOpts, sink chan<- *ContractsUserDeleted, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "UserDeleted", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsUserDeleted)
				if err := _Contracts.contract.UnpackLog(event, "UserDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUserDeleted is a log parse operation binding the contract event 0xc26eb30613e535870aeacfc24e58a8fb60e992f0d8bfe04ec9c98db26b53c5e5.
//
// Solidity: event UserDeleted(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseUserDeleted(log types.Log) (*ContractsUserDeleted, error) {
	event := new(ContractsUserDeleted)
	if err := _Contracts.contract.UnpackLog(event, "UserDeleted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsUserRegisteredIterator is returned from FilterUserRegistered and is used to iterate over the raw logs and unpacked data for UserRegistered events raised by the Contracts contract.
type ContractsUserRegisteredIterator struct {
	Event *ContractsUserRegistered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsUserRegisteredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsUserRegistered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsUserRegistered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsUserRegisteredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsUserRegisteredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsUserRegistered represents a UserRegistered event raised by the Contracts contract.
type ContractsUserRegistered struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUserRegistered is a free log retrieval operation binding the contract event 0x78997021e09413de1e36500ed07f9f6c73541162817fc3ea6a115e5e3d3affb9.
//
// Solidity: event UserRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterUserRegistered(opts *bind.FilterOpts, id [][32]byte) (*ContractsUserRegisteredIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "UserRegistered", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsUserRegisteredIterator{contract: _Contracts.contract, event: "UserRegistered", logs: logs, sub: sub}, nil
}

// WatchUserRegistered is a free log subscription operation binding the contract event 0x78997021e09413de1e36500ed07f9f6c73541162817fc3ea6a115e5e3d3affb9.
//
// Solidity: event UserRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchUserRegistered(opts *bind.WatchOpts, sink chan<- *ContractsUserRegistered, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "UserRegistered", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsUserRegistered)
				if err := _Contracts.contract.UnpackLog(event, "UserRegistered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUserRegistered is a log parse operation binding the contract event 0x78997021e09413de1e36500ed07f9f6c73541162817fc3ea6a115e5e3d3affb9.
//
// Solidity: event UserRegistered(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseUserRegistered(log types.Log) (*ContractsUserRegistered, error) {
	event := new(ContractsUserRegistered)
	if err := _Contracts.contract.UnpackLog(event, "UserRegistered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContractsUserUpdatedIterator is returned from FilterUserUpdated and is used to iterate over the raw logs and unpacked data for UserUpdated events raised by the Contracts contract.
type ContractsUserUpdatedIterator struct {
	Event *ContractsUserUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContractsUserUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContractsUserUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContractsUserUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContractsUserUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContractsUserUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContractsUserUpdated represents a UserUpdated event raised by the Contracts contract.
type ContractsUserUpdated struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUserUpdated is a free log retrieval operation binding the contract event 0xdf3a752736081f0b857124cd76b543d42ea93c426e4ae00b28927d4de82ee102.
//
// Solidity: event UserUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) FilterUserUpdated(opts *bind.FilterOpts, id [][32]byte) (*ContractsUserUpdatedIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.FilterLogs(opts, "UserUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return &ContractsUserUpdatedIterator{contract: _Contracts.contract, event: "UserUpdated", logs: logs, sub: sub}, nil
}

// WatchUserUpdated is a free log subscription operation binding the contract event 0xdf3a752736081f0b857124cd76b543d42ea93c426e4ae00b28927d4de82ee102.
//
// Solidity: event UserUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) WatchUserUpdated(opts *bind.WatchOpts, sink chan<- *ContractsUserUpdated, id [][32]byte) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _Contracts.contract.WatchLogs(opts, "UserUpdated", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContractsUserUpdated)
				if err := _Contracts.contract.UnpackLog(event, "UserUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUserUpdated is a log parse operation binding the contract event 0xdf3a752736081f0b857124cd76b543d42ea93c426e4ae00b28927d4de82ee102.
//
// Solidity: event UserUpdated(bytes32 indexed id)
func (_Contracts *ContractsFilterer) ParseUserUpdated(log types.Log) (*ContractsUserUpdated, error) {
	event := new(ContractsUserUpdated)
	if err := _Contracts.contract.UnpackLog(event, "UserUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
