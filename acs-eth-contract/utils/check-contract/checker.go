package main

import (
	"context"
	"fmt"
	"math/big"

	// Smart contract generated by abigen
	acs_registry "acs-eth/contracts"
	"acs-eth/utils"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

func main() {
	// 1) Get environment variables
	rpcURL := utils.GetEnv("RPC_URL")
	privKeyHex := utils.GetEnv("PRIVATE_KEY")[2:] // 0x 잘라내기
	chainID, _ := new(big.Int).SetString(utils.GetEnv("CHAIN_ID"), 10)
	registryAddr := utils.GetEnv("ACS_REGISTRY_ADDR")

	// 2) Connect to RPC endpoint
	client, err := ethclient.Dial(rpcURL)
	if err != nil {
		fmt.Printf("RPC connection failed: %v\n", err)
		return
	}
	defer client.Close()

	// 3) Prepare the signer with user's private key
	key, _ := crypto.HexToECDSA(privKeyHex)
	signer, _ := bind.NewKeyedTransactorWithChainID(key, chainID)
	signer.GasLimit = 5000000 // Set gas limit for the transaction

	// 4) Check if the account is unlocked and has enough balance to deploy the contract
	balance, err := client.BalanceAt(context.Background(), signer.From, nil)
	if err != nil {
		fmt.Printf("Failed to fetch balance: %v\n", err)
		return
	}
	fmt.Printf("Account balance: %s wei\n", balance.String())

	if balance.Cmp(big.NewInt(0)) == 0 {
		fmt.Printf("Not enough balance. Can't execute transaction.")
		return
	}

	// 5. Get the deployed contract instance
	address := common.HexToAddress(registryAddr)
	println("ACS registry address:", address.Hex())
	contracts, err := acs_registry.NewContracts(address, client)
	if err != nil {
		fmt.Printf("No smart contract found[%s]: %+v\n", address.String(), err)
		return
	}
	fmt.Println("ACS registry instance:", contracts)

	// 6. Check if the contract is deployed
	code, err := client.CodeAt(context.Background(), address, nil)
	if err != nil {
		fmt.Printf("Failed to fetch contract code: %v", err)
		return
	}

	if len(code) == 0 {
		fmt.Printf("No contract code found at address: %s\n", address.Hex())
		return
	}
	fmt.Printf("Contract code found at address: %s\n", address.Hex())
	fmt.Println("==============================================================")

	// 7. Try a read transaction using GetData()
	// Replace "_cid" and "" with valid arguments as per the smart contract's requirements
	validCid := "exampleCid" // Replace with an actual valid CID
	data, err := contracts.GetData(&bind.CallOpts{}, validCid)
	if err != nil {
		fmt.Printf("GetData() failed: %v\n", err)
	} else {
		fmt.Println("GetData() succeeded:", data)
	}

	// 8. Try a write transaction using AddData()
	dataName := "exampleDataName"  // Replace with actual data name
	dataSize := big.NewInt(123456) // Replace with actual data size
	dataOwner := "exampleOwner"    // Replace with actual data owner
	dataCid := "exampleCid"        // Replace with actual CID
	dataEnc := "ddd"               // Replace with actual encryption method if needed
	dataCreated := "ccc"           // Replace with actual creation date if needed
	dataRev := "bbb"               // Replace with actual revision date if needed
	dataMeta := "aaa"              // Replace with actual metadata if needed
	tx, err := contracts.PutData(signer, dataName, dataSize, dataOwner, dataCid, dataEnc, dataCreated, dataRev, dataMeta)
	if err != nil {
		fmt.Printf("PutData() failed: %v", err)
		return
	}
	fmt.Println("PutData() succeeded, tx:", tx.Hash().Hex())

	// 9. Wait for the completion of the write transaction
	receipt, err := bind.WaitMined(context.Background(), client, tx)
	if err != nil {
		fmt.Printf("WaitMined() failed: %v", err)
		return
	}
	fmt.Println("    ✅ Receipt's BlockNumber:", receipt.BlockNumber)

	// 10. Try a read transaction for the written data
	_data, err := contracts.GetData(&bind.CallOpts{}, dataCid)
	fmt.Println("GetData()/ dataCid:", dataCid)
	if err != nil {
		fmt.Printf("GetData() failed: %v\n", err)
	} else {
		fmt.Println("GetDataInfo():", _data)
	}
	fmt.Println("==============================================================")

	// 11. Try a write transaction using UpdateData()
	newMetaData := "newMetaData" // Replace with actual new metadata if needed
	tx, err = contracts.UpdateData(signer, dataOwner, dataCid, newMetaData)
	if err != nil {
		fmt.Printf("UpdateData() failed: %v", err)
		return
	}
	fmt.Println("UpdateData() succeeded, tx:", tx.Hash().Hex())

	// 12. Wait for the completion of the write transaction
	receipt3, err := bind.WaitMined(context.Background(), client, tx)
	if err != nil {
		fmt.Printf("WaitMined() failed: %v", err)
		return
	}
	fmt.Println("    ✅ Receipt's BlockNumber:", receipt3.BlockNumber)
	return
	// 13. Try a read transaction for the written data
	_dataU, err := contracts.GetData(&bind.CallOpts{}, dataCid)
	if err != nil {
		fmt.Printf("GetData() failed: %v\n", err)
	} else {
		fmt.Println("✅ GetData() succeeded:", _dataU)
	}
	fmt.Println("==============================================================")

	// 14. Try a write transaction using DeleteData()
	tx, err = contracts.DeleteData(signer, dataOwner, dataCid)
	if err != nil {
		fmt.Printf("DeleteData() failed: %v", err)
		return
	}
	fmt.Println("DeleteData() succeeded, tx:", tx.Hash().Hex())

	// 5. Wait for the completion of the write transaction
	receipt2, err := bind.WaitMined(context.Background(), client, tx)
	if err != nil {
		fmt.Printf("WaitMined() failed: %v", err)
		return
	}
	fmt.Println("    ✅ Receipt's BlockNumber:", receipt2.BlockNumber)

	// 16. Try a read transaction for the deleted data
	_dataD, err := contracts.GetData(&bind.CallOpts{}, dataCid)
	if err != nil {
		fmt.Printf("✅ GetData() failed: %v\n", err)
	} else {
		fmt.Println("GetData() succeeded:", _dataD)
	}
	fmt.Println("==============================================================")
}
