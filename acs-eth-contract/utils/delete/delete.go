package main

import (
	"context"
	"fmt"
	"math/big"

	// Smart contract generated by abigen
	acs_registry "acs-eth/contracts"
	"acs-eth/utils"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

func main() {
	// 1) Get environment variables
	rpcURL := utils.GetEnv("RPC_URL")
	privKeyHex := utils.GetEnv("PRIVATE_KEY")[2:] // 0x 잘라내기
	chainID, _ := new(big.Int).SetString(utils.GetEnv("CHAIN_ID"), 10)
	registryAddr := utils.GetEnv("ACS_REGISTRY_ADDR")

	// 2) Connect to RPC endpoint
	client, err := ethclient.Dial(rpcURL)
	if err != nil {
		fmt.Printf("RPC connection failed: %v\n", err)
		return
	}
	defer client.Close()

	// 3) Prepare the signer with user's private key
	key, _ := crypto.HexToECDSA(privKeyHex)
	signer, _ := bind.NewKeyedTransactorWithChainID(key, chainID)

	// 4) Check if the account is unlocked and has enough balance to deploy the contract
	balance, err := client.BalanceAt(context.Background(), signer.From, nil)
	if err != nil {
		fmt.Printf("Failed to fetch balance: %v\n", err)
		return
	}
	fmt.Printf("Account balance: %s wei\n", balance.String())

	if balance.Cmp(big.NewInt(0)) == 0 {
		fmt.Printf("Not enough balance. Can't execute transaction.")
		return
	}

	// 5. Get the deployed contract instance
	address := common.HexToAddress(registryAddr)
	println("ACS registry address:", address.Hex())
	contracts, err := acs_registry.NewContracts(address, client)
	if err != nil {
		fmt.Printf("No smart contract found[%s]: %+v\n", address.String(), err)
		return
	}
	fmt.Println("ACS registry instance:", contracts)

	// 6. Check if the contract is deployed
	code, err := client.CodeAt(context.Background(), address, nil)
	if err != nil {
		fmt.Printf("Failed to fetch contract code: %v", err)
		return
	}

	if len(code) == 0 {
		fmt.Printf("No contract code found at address: %s\n", address.Hex())
		return
	}
	fmt.Printf("Contract code found at address: %s\n", address.Hex())

	// 8. Try a write transaction using DeleteData()
	dataOwner := "exampleOwner" // Replace with actual data owner
	dataCid := "exampleCid"     // Replace with actual CID

	// 13. Try a write transaction using DeleteData()
	tx, err := contracts.DeleteData(signer, dataOwner, dataCid)
	if err != nil {
		fmt.Printf("DeleteData() failed: %v", err)
		return
	}
	fmt.Println("DeleteData() succeeded, tx:", tx.Hash().Hex())

	// 9. Wait for the completion of the write transaction
	receipt, err := bind.WaitMined(context.Background(), client, tx)
	if err != nil {
		fmt.Printf("WaitMined() failed: %v", err)
		return
	}
	fmt.Println("    ✅ Receipt's BlockNumber:", receipt.BlockNumber)

	// 14. Try a read transaction for the deleted data
	_dataD, err := contracts.GetData(&bind.CallOpts{}, "exampleCid")
	if err != nil {
		fmt.Printf("✅ GetData() failed: %v\n", err)
	} else {
		fmt.Println("GetData() succeeded:", _dataD)
	}

}
